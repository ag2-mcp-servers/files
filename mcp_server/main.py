# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T03:34:25+00:00



import argparse
import json
import os
from datetime import datetime
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import (
    APIKeyHeader,
    APIKeyQuery,
    BaseSecurity,
    UnsuportedSecurityStub,
)
from fastapi import Path, Query, UploadFile
from pydantic import constr

from models import (
    CollectionResponseFile,
    CollectionResponseFolder,
    Error,
    File,
    FileActionResponse,
    FileUpdateInput,
    Folder,
    FolderActionResponse,
    FolderInput,
    FolderUpdateInput,
    FolderUpdateTaskLocator,
    ImportFromUrlInput,
    ImportFromUrlTaskLocator,
    Properties,
    SignedUrl,
    Size,
    Sort,
)

app = MCPProxy(
    description='Upload and manage files.',
    title='Files',
    version='v3',
    servers=[{'url': 'https://api.hubapi.com/'}],
)


@app.post(
    '/files/v3/files',
    description=""" Upload a single file with content specified in request body. """,
    tags=['file_handling', 'file_import_management'],
    security=[
        APIKeyQuery(name="hapikey"),
        APIKeyHeader(name="private-app-legacy"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def post__files_v3_files_upload(file: UploadFile):
    """
    Upload file
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/files/v3/files/import-from-url/async',
    description=""" Asynchronously imports the file at the given URL into the file manager. """,
    tags=['file_handling', 'file_import_management'],
    security=[
        APIKeyQuery(name="hapikey"),
        APIKeyHeader(name="private-app-legacy"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def post__files_v3_files_import_from_url_async_import_from_url(
    body: ImportFromUrlInput,
):
    """
    Import a file from a URL into the file manager.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/files/v3/files/import-from-url/async/tasks/{taskId}/status',
    description=""" Check the status of requested import. """,
    tags=['file_import_management'],
    security=[
        APIKeyHeader(name="private-app-legacy"),
        UnsuportedSecurityStub(name="None"),
        APIKeyQuery(name="hapikey"),
        APIKeyHeader(name="private-app-legacy"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def check_import_status_by_task_id(task_id: str = Path(..., alias='taskId')):
    """
    Check import status.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/files/v3/files/search',
    description=""" Search through files in the file manager. Does not display hidden or archived files. """,
    tags=['file_handling', 'folder_handling'],
    security=[
        APIKeyHeader(name="private-app-legacy"),
        UnsuportedSecurityStub(name="None"),
        APIKeyQuery(name="hapikey"),
        APIKeyHeader(name="private-app-legacy"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get__files_v3_files_search_do_search(
    properties: Optional[Properties] = None,
    after: Optional[str] = None,
    before: Optional[str] = None,
    limit: Optional[int] = None,
    sort: Optional[Sort] = None,
    id: Optional[str] = None,
    created_at: Optional[datetime] = Query(None, alias='createdAt'),
    created_at_lte: Optional[datetime] = Query(None, alias='createdAtLte'),
    created_at_gte: Optional[datetime] = Query(None, alias='createdAtGte'),
    updated_at: Optional[datetime] = Query(None, alias='updatedAt'),
    updated_at_lte: Optional[datetime] = Query(None, alias='updatedAtLte'),
    updated_at_gte: Optional[datetime] = Query(None, alias='updatedAtGte'),
    name: Optional[str] = None,
    path: Optional[str] = None,
    parent_folder_id: Optional[int] = Query(None, alias='parentFolderId'),
    size: Optional[int] = None,
    height: Optional[int] = None,
    width: Optional[int] = None,
    encoding: Optional[str] = None,
    type: Optional[str] = None,
    extension: Optional[str] = None,
    url: Optional[str] = None,
    is_usable_in_content: Optional[bool] = Query(None, alias='isUsableInContent'),
    allows_anonymous_access: Optional[bool] = Query(
        None, alias='allowsAnonymousAccess'
    ),
):
    """
    Search files
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/files/v3/files/{fileId}',
    description=""" Delete file by ID """,
    tags=['file_handling', 'gdpr_regulation_compliance'],
    security=[
        APIKeyQuery(name="hapikey"),
        APIKeyHeader(name="private-app-legacy"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete__files_v3_files__file_id__archive(
    file_id: constr(pattern=r'\d+') = Path(..., alias='fileId')
):
    """
    Delete file
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/files/v3/files/{fileId}',
    description=""" Get file by ID. """,
    tags=['file_handling', 'file_access_controls'],
    security=[
        APIKeyHeader(name="private-app-legacy"),
        UnsuportedSecurityStub(name="None"),
        APIKeyQuery(name="hapikey"),
        APIKeyHeader(name="private-app-legacy"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get__files_v3_files__file_id__get_by_id(
    file_id: constr(pattern=r'\d+') = Path(..., alias='fileId'),
    properties: Optional[Properties] = None,
):
    """
    Get file.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/files/v3/files/{fileId}',
    description=""" Update properties of file by ID. """,
    tags=['file_handling'],
    security=[
        APIKeyQuery(name="hapikey"),
        APIKeyHeader(name="private-app-legacy"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def patch__files_v3_files__file_id__update_properties(
    file_id: constr(pattern=r'\d+') = Path(..., alias='fileId'),
    body: FileUpdateInput = ...,
):
    """
    update file properties
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/files/v3/files/{fileId}',
    description=""" Replace existing file data with new file data. Can be used to change image content without having to upload a new file and update all references. """,
    tags=['file_handling'],
    security=[
        APIKeyQuery(name="hapikey"),
        APIKeyHeader(name="private-app-legacy"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def put__files_v3_files__file_id__replace(
    file_id: constr(pattern=r'\d+') = Path(..., alias='fileId'), file: UploadFile = ...
):
    """
    Replace file.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/files/v3/files/{fileId}/gdpr-delete',
    description=""" GDRP delete file """,
    tags=['file_handling', 'gdpr_regulation_compliance'],
    security=[
        APIKeyQuery(name="hapikey"),
        APIKeyHeader(name="private-app-legacy"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete__files_v3_files__file_id__gdpr_delete_archive_g_d_p_r(
    file_id: constr(pattern=r'\d+') = Path(..., alias='fileId')
):
    """
    GDPR delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/files/v3/files/{fileId}/signed-url',
    description=""" Generates signed URL that allows temporary access to a private file. """,
    tags=['file_access_controls', 'file_handling'],
    security=[
        APIKeyHeader(name="private-app-legacy"),
        UnsuportedSecurityStub(name="None"),
        APIKeyQuery(name="hapikey"),
        APIKeyHeader(name="private-app-legacy"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get__files_v3_files__file_id__signed_url_get_signed_url(
    file_id: constr(pattern=r'\d+') = Path(..., alias='fileId'),
    size: Optional[Size] = None,
    expiration_seconds: Optional[int] = Query(None, alias='expirationSeconds'),
    upscale: Optional[bool] = None,
):
    """
    Get signed URL to access private file.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/files/v3/folders',
    description=""" Creates a folder. """,
    tags=['folder_handling'],
    security=[
        APIKeyQuery(name="hapikey"),
        APIKeyHeader(name="private-app-legacy"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def post__files_v3_folders_create(body: FolderInput):
    """
    Create folder.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/files/v3/folders/search',
    description=""" Search for folders. Does not contain hidden or archived folders. """,
    tags=['folder_handling'],
    security=[
        APIKeyHeader(name="private-app-legacy"),
        UnsuportedSecurityStub(name="None"),
        APIKeyQuery(name="hapikey"),
        APIKeyHeader(name="private-app-legacy"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get__files_v3_folders_search_do_search(
    properties: Optional[Properties] = None,
    after: Optional[str] = None,
    before: Optional[str] = None,
    limit: Optional[int] = None,
    sort: Optional[Sort] = None,
    id: Optional[str] = None,
    created_at: Optional[datetime] = Query(None, alias='createdAt'),
    created_at_lte: Optional[datetime] = Query(None, alias='createdAtLte'),
    created_at_gte: Optional[datetime] = Query(None, alias='createdAtGte'),
    updated_at: Optional[datetime] = Query(None, alias='updatedAt'),
    updated_at_lte: Optional[datetime] = Query(None, alias='updatedAtLte'),
    updated_at_gte: Optional[datetime] = Query(None, alias='updatedAtGte'),
    name: Optional[str] = None,
    path: Optional[str] = None,
    parent_folder_id: Optional[int] = Query(None, alias='parentFolderId'),
):
    """
    Search folders
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/files/v3/folders/update/async',
    description=""" Update properties of folder by given ID. This action happens asynchronously and will update all of the folder's children as well. """,
    tags=['folder_handling'],
    security=[
        APIKeyQuery(name="hapikey"),
        APIKeyHeader(name="private-app-legacy"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def post__files_v3_folders_update_async_update_properties(body: FolderUpdateInput):
    """
    Update folder properties
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/files/v3/folders/update/async/tasks/{taskId}/status',
    description=""" Check status of folder update. Folder updates happen asynchronously. """,
    tags=['folder_handling', 'file_handling'],
    security=[
        APIKeyQuery(name="hapikey"),
        APIKeyHeader(name="private-app-legacy"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def check_folder_update_status_by_task_id(task_id: str = Path(..., alias='taskId')):
    """
    Check folder update status.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/files/v3/folders/{folderId}',
    description=""" Delete folder by ID. """,
    tags=['folder_handling'],
    security=[
        APIKeyQuery(name="hapikey"),
        APIKeyHeader(name="private-app-legacy"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete__files_v3_folders__folder_id__archive(
    folder_id: constr(pattern=r'\d+') = Path(..., alias='folderId')
):
    """
    Delete folder.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/files/v3/folders/{folderId}',
    description=""" Get folder by ID """,
    tags=['folder_handling'],
    security=[
        APIKeyHeader(name="private-app-legacy"),
        UnsuportedSecurityStub(name="None"),
        APIKeyQuery(name="hapikey"),
        APIKeyHeader(name="private-app-legacy"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get__files_v3_folders__folder_id__get_by_id(
    folder_id: constr(pattern=r'\d+') = Path(..., alias='folderId'),
    properties: Optional[Properties] = None,
):
    """
    Get folder
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/files/v3/folders/{folderPath}',
    description=""" Delete folder by path. """,
    tags=['folder_handling'],
    security=[
        APIKeyQuery(name="hapikey"),
        APIKeyHeader(name="private-app-legacy"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete__files_v3_folders__folder_path__archive_by_path(
    folder_path: constr(pattern=r'.+') = Path(..., alias='folderPath')
):
    """
    Delete folder.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/files/v3/folders/{folderPath}',
    description=""" Get folder by path. """,
    tags=['folder_handling'],
    security=[
        APIKeyHeader(name="private-app-legacy"),
        UnsuportedSecurityStub(name="None"),
        APIKeyQuery(name="hapikey"),
        APIKeyHeader(name="private-app-legacy"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get__files_v3_folders__folder_path__get_by_path(
    folder_path: constr(pattern=r'.+') = Path(..., alias='folderPath'),
    properties: Optional[Properties] = None,
):
    """
    Get folder.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
