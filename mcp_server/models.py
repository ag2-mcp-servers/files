# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T03:34:25+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional
from uuid import UUID

from pydantic import BaseModel, Field, RootModel


class HttpStatus(Enum):
    CONTINUE = 'CONTINUE'
    SWITCHING_PROTOCOLS = 'SWITCHING_PROTOCOLS'
    PROCESSING = 'PROCESSING'
    OK = 'OK'
    CREATED = 'CREATED'
    ACCEPTED = 'ACCEPTED'
    NON_AUTHORITATIVE_INFORMATION = 'NON_AUTHORITATIVE_INFORMATION'
    NO_CONTENT = 'NO_CONTENT'
    RESET_CONTENT = 'RESET_CONTENT'
    PARTIAL_CONTENT = 'PARTIAL_CONTENT'
    MULTI_STATUS = 'MULTI_STATUS'
    ALREADY_REPORTED = 'ALREADY_REPORTED'
    IM_USED = 'IM_USED'
    MULTIPLE_CHOICES = 'MULTIPLE_CHOICES'
    MOVED_PERMANENTLY = 'MOVED_PERMANENTLY'
    FOUND = 'FOUND'
    SEE_OTHER = 'SEE_OTHER'
    NOT_MODIFIED = 'NOT_MODIFIED'
    USE_PROXY = 'USE_PROXY'
    TEMPORARY_REDIRECT = 'TEMPORARY_REDIRECT'
    PERMANENT_REDIRECT = 'PERMANENT_REDIRECT'
    BAD_REQUEST = 'BAD_REQUEST'
    UNAUTHORIZED = 'UNAUTHORIZED'
    PAYMENT_REQUIRED = 'PAYMENT_REQUIRED'
    FORBIDDEN = 'FORBIDDEN'
    NOT_FOUND = 'NOT_FOUND'
    METHOD_NOT_ALLOWED = 'METHOD_NOT_ALLOWED'
    NOT_ACCEPTABLE = 'NOT_ACCEPTABLE'
    PROXY_AUTHENTICATION_REQUIRED = 'PROXY_AUTHENTICATION_REQUIRED'
    REQUEST_TIMEOUT = 'REQUEST_TIMEOUT'
    CONFLICT = 'CONFLICT'
    GONE = 'GONE'
    LENGTH_REQUIRED = 'LENGTH_REQUIRED'
    PRECONDITION_FAILED = 'PRECONDITION_FAILED'
    REQUEST_ENTITY_TOO_LARGE = 'REQUEST_ENTITY_TOO_LARGE'
    REQUEST_URI_TOO_LONG = 'REQUEST_URI_TOO_LONG'
    UNSUPPORTED_MEDIA_TYPE = 'UNSUPPORTED_MEDIA_TYPE'
    REQUESTED_RANGE_NOT_SATISFIABLE = 'REQUESTED_RANGE_NOT_SATISFIABLE'
    EXPECTATION_FAILED = 'EXPECTATION_FAILED'
    IM_A_TEAPOT = 'IM_A_TEAPOT'
    MISDIRECTED_REQUEST = 'MISDIRECTED_REQUEST'
    UNPROCESSABLE_ENTITY = 'UNPROCESSABLE_ENTITY'
    LOCKED = 'LOCKED'
    FAILED_DEPENDENCY = 'FAILED_DEPENDENCY'
    UPGRADE_REQUIRED = 'UPGRADE_REQUIRED'
    PRECONDITION_REQUIRED = 'PRECONDITION_REQUIRED'
    TOO_MANY_REQUESTS = 'TOO_MANY_REQUESTS'
    REQUEST_HEADERS_FIELDS_TOO_LARGE = 'REQUEST_HEADERS_FIELDS_TOO_LARGE'
    INTERNAL_STALE_SERVICE_DISCOVERY = 'INTERNAL_STALE_SERVICE_DISCOVERY'
    UNAVAILABLE_FOR_LEGAL_REASONS = 'UNAVAILABLE_FOR_LEGAL_REASONS'
    INTERNAL_SERVER_ERROR = 'INTERNAL_SERVER_ERROR'
    NOT_IMPLEMENTED = 'NOT_IMPLEMENTED'
    BAD_GATEWAY = 'BAD_GATEWAY'
    SERVICE_UNAVAILABLE = 'SERVICE_UNAVAILABLE'
    GATEWAY_TIMEOUT = 'GATEWAY_TIMEOUT'
    HTTP_VERSION_NOT_SUPPORTED = 'HTTP_VERSION_NOT_SUPPORTED'
    VARIANT_ALSO_NEGOTIATES = 'VARIANT_ALSO_NEGOTIATES'
    INSUFFICIENT_STORAGE = 'INSUFFICIENT_STORAGE'
    LOOP_DETECTED = 'LOOP_DETECTED'
    NOT_EXTENDED = 'NOT_EXTENDED'
    NETWORK_AUTHENTICATION_REQUIRED = 'NETWORK_AUTHENTICATION_REQUIRED'


class ErrorCategory(BaseModel):
    httpStatus: HttpStatus
    name: str


class ErrorDetail(BaseModel):
    code: Optional[str] = Field(
        None, description='The status code associated with the error detail'
    )
    context: Optional[Dict[str, List[str]]] = Field(
        None,
        description='Context about the error condition',
        examples=[{'missingScopes': ['scope1', 'scope2']}],
    )
    in_: Optional[str] = Field(
        None,
        alias='in',
        description='The name of the field or parameter in which the error was found.',
    )
    message: str = Field(
        ...,
        description='A human readable message describing the error along with remediation steps where appropriate',
    )
    subCategory: Optional[str] = Field(
        None,
        description='A specific category that contains more specific detail about the error',
    )


class Access(Enum):
    PUBLIC_INDEXABLE = 'PUBLIC_INDEXABLE'
    PUBLIC_NOT_INDEXABLE = 'PUBLIC_NOT_INDEXABLE'
    HIDDEN_INDEXABLE = 'HIDDEN_INDEXABLE'
    HIDDEN_NOT_INDEXABLE = 'HIDDEN_NOT_INDEXABLE'
    HIDDEN_PRIVATE = 'HIDDEN_PRIVATE'
    PRIVATE = 'PRIVATE'


class File(BaseModel):
    access: Access = Field(
        ...,
        description='File access. Can be PUBLIC_INDEXABLE, PUBLIC_NOT_INDEXABLE, PRIVATE.',
    )
    archived: bool = Field(..., description='If the file is deleted.')
    archivedAt: Optional[datetime] = Field(
        None, description='Deletion time of the file object.'
    )
    createdAt: datetime = Field(..., description='Creation time of the file object.')
    defaultHostingUrl: Optional[str] = Field(
        None,
        description="Default hosting URL of the file. This will use one of HubSpot's provided URLs to serve the file.",
    )
    encoding: Optional[str] = Field(None, description='Encoding of the file.')
    extension: Optional[str] = Field(
        None, description='Extension of the file. For example png.'
    )
    height: Optional[int] = Field(
        None, description='For image and video files, the height of the content.'
    )
    id: str = Field(..., description='File ID.')
    isUsableInContent: Optional[bool] = Field(
        None,
        description='Previously "archied". Indicates if the file should be used when creating new content like web pages.',
    )
    name: Optional[str] = Field(None, description='Name of the file.')
    parentFolderId: Optional[str] = Field(
        None, description='Id of the folder the file is in.'
    )
    path: Optional[str] = Field(
        None, description='Path of the file in the file manager.'
    )
    size: Optional[int] = Field(None, description='Size in bytes of the file.')
    type: Optional[str] = Field(
        None,
        description='Type of the file. Can be IMG, DOCUMENT, AUDIO, MOVIE, or OTHER.',
    )
    updatedAt: datetime = Field(
        ..., description='Timestamp of the latest update to the file.'
    )
    url: Optional[str] = Field(
        None,
        description='URL of the given file. This URL can change depending on the domain settings of the account. Will use the select file hosting domain.',
    )
    width: Optional[int] = Field(
        None, description='For image and video files, the width of the content.'
    )


class Status(Enum):
    PENDING = 'PENDING'
    PROCESSING = 'PROCESSING'
    CANCELED = 'CANCELED'
    COMPLETE = 'COMPLETE'


class FileUpdateInput(BaseModel):
    access: Optional[Access] = Field(
        None,
        description='NONE: Do not run any duplicate validation. REJECT: Reject the upload if a duplicate is found. RETURN_EXISTING: If a duplicate file is found, do not upload a new file and return the found duplicate instead.\n',
    )
    isUsableInContent: Optional[bool] = Field(
        None, description='Mark weather the file should be used in new content or not.'
    )
    name: Optional[str] = Field(None, description='New name for the file.')
    parentFolderId: Optional[str] = Field(
        None,
        description='Folder ID where the file should be moved to.  folderId and folderPath cannot be set at the same time.',
    )
    parentFolderPath: Optional[str] = Field(
        None,
        description='Folder path where the file should be moved to. folderId and folderPath cannot be set at the same time.',
    )


class Folder(BaseModel):
    archived: bool = Field(
        ..., description='Marks weather the folder is deleted or not.'
    )
    archivedAt: Optional[datetime] = Field(
        None, description='Timestamp of folder deletion.'
    )
    createdAt: datetime = Field(..., description='Timestamp of folder creation.')
    id: str = Field(..., description='Id of the folder.')
    name: Optional[str] = Field(None, description='Name of the folder.')
    parentFolderId: Optional[str] = Field(None, description='Id of the parent folder.')
    path: Optional[str] = Field(
        None, description='Path of the folder in the file manager.'
    )
    updatedAt: datetime = Field(
        ..., description='Timestamp of the latest update to the folder.'
    )


class FolderInput(BaseModel):
    name: str = Field(..., description='Desired name for the folder.')
    parentFolderId: Optional[str] = Field(
        None,
        description='Folder ID of the parent of the created folder. If not specified, the folder will be created at the root level. parentFolderId and parentFolderPath cannot be set at the same time.',
    )
    parentPath: Optional[str] = Field(
        None,
        description='Path of the parent of the created folder. If not specified the folder will be created at the root level. parentFolderPath and parentFolderId cannot be set at the same time.',
    )


class FolderUpdateInput(BaseModel):
    id: str = Field(..., description='Id of the folder to change.')
    name: Optional[str] = Field(
        None,
        description="New name. If specified the folder's name and fullPath will change. All children of the folder will be updated accordingly.",
    )
    parentFolderId: Optional[int] = Field(
        None,
        description="New parent folder ID. If changed, the folder and all it's children will be moved into the specified folder. parentFolderId and parentFolderPath cannot be specified at the same time.",
    )


class FolderUpdateTaskLocator(BaseModel):
    id: str = Field(..., description='The ID of the task')
    links: Optional[Dict[str, str]] = Field(
        None,
        description='Links for where to check information related to the task. The `status` link gives the URL for where to check the status of the task.',
    )


class DuplicateValidationScope(Enum):
    ENTIRE_PORTAL = 'ENTIRE_PORTAL'
    EXACT_FOLDER = 'EXACT_FOLDER'


class DuplicateValidationStrategy(Enum):
    NONE = 'NONE'
    REJECT = 'REJECT'
    RETURN_EXISTING = 'RETURN_EXISTING'


class ImportFromUrlInput(BaseModel):
    access: Access = Field(
        ...,
        description="PUBLIC_INDEXABLE: File is publicly accessible by anyone who has the URL. Search engines can index the file. PUBLIC_NOT_INDEXABLE: File is publicly accessible by anyone who has the URL. Search engines *can't* index the file. PRIVATE: File is NOT publicly accessible. Requires a signed URL to see content. Search engines *can't* index the file.\n",
    )
    duplicateValidationScope: DuplicateValidationScope = Field(
        ...,
        description='ENTIRE_PORTAL: Look for a duplicate file in the entire account. EXACT_FOLDER: Look for a duplicate file in the provided folder.\n',
    )
    duplicateValidationStrategy: DuplicateValidationStrategy = Field(
        ...,
        description='NONE: Do not run any duplicate validation. REJECT: Reject the upload if a duplicate is found. RETURN_EXISTING: If a duplicate file is found, do not upload a new file and return the found duplicate instead.\n',
    )
    folderId: Optional[str] = Field(
        None,
        description='One of folderId or folderPath is required. Destination folder ID for the uploaded file.',
    )
    folderPath: Optional[str] = Field(
        None,
        description='One of folderPath or folderId is required. Destination folder path for the uploaded file. If the folder path does not exist, there will be an attempt to create the folder path.',
    )
    name: Optional[str] = Field(
        None, description='Name to give the resulting file in the file manager.'
    )
    overwrite: bool = Field(
        ...,
        description='If true, it will overwrite existing files if a file with the same name exists in the given folder.',
    )
    ttl: Optional[str] = Field(
        None,
        description='Time to live. If specified the file will be deleted after the given time frame.',
    )
    url: str = Field(..., description='URL to download the new file from.')


class ImportFromUrlTaskLocator(BaseModel):
    id: str = Field(..., description='The ID of the task')
    links: Optional[Dict[str, str]] = Field(
        None,
        description='Links for where to check information related to the task. The `status` link gives the URL for where to check the status of the task.',
    )


class NextPage(BaseModel):
    after: str
    link: Optional[str] = None


class PreviousPage(BaseModel):
    before: str
    link: Optional[str] = None


class SignedUrl(BaseModel):
    expiresAt: datetime = Field(
        ...,
        description='Timestamp of when the URL will no longer grant access to the file.',
    )
    extension: str = Field(..., description='Extension of the requested file.')
    height: Optional[int] = Field(
        None, description='For image and video files. The height of the file.'
    )
    name: str = Field(..., description='Name of the requested file.')
    size: int = Field(..., description='Size in bytes of the requested file.')
    type: str = Field(
        ...,
        description='Type of the file. Can be IMG, DOCUMENT, AUDIO, MOVIE, or OTHER.',
    )
    url: str = Field(
        ...,
        description='Signed URL with access to the specified file. Anyone with this URL will be able to access the file until it expires.',
    )
    width: Optional[int] = Field(
        None, description='For image and video files. The width of the file.'
    )


class StandardError(BaseModel):
    category: ErrorCategory
    context: Dict[str, List[str]]
    errors: List[ErrorDetail]
    id: Optional[str] = None
    links: Dict[str, str]
    message: str
    status: str
    subCategory: Optional[Dict[str, Any]] = None


class FilesV3FilesPostRequest(BaseModel):
    charsetHunch: Optional[str] = Field(
        None, description='Character set of the uploaded file.'
    )
    file: Optional[bytes] = Field(None, description='File to be uploaded.')
    fileName: Optional[str] = Field(
        None, description='Desired name for the uploaded file.'
    )
    folderId: Optional[str] = Field(
        None,
        description="Either 'folderId' or 'folderPath' is required. folderId is the ID of the folder the file will be uploaded to.",
    )
    folderPath: Optional[str] = Field(
        None,
        description="Either 'folderPath' or 'folderId' is required. This field represents the destination folder path for the uploaded file. If a path doesn't exist, the system will try to create one.",
    )
    options: Optional[str] = Field(
        None, description='JSON string representing FileUploadOptions.'
    )


class Properties(RootModel[List[str]]):
    root: List[str]


class Sort(RootModel[List[str]]):
    root: List[str]


class FilesV3FilesFileIdPutRequest(BaseModel):
    charsetHunch: Optional[str] = Field(
        None, description='Character set of given file data.'
    )
    file: Optional[bytes] = Field(
        None,
        description='File data that will replace existing file in the file manager.',
    )
    options: Optional[str] = Field(
        None, description='JSON String representing FileReplaceOptions'
    )


class Size(Enum):
    thumb = 'thumb'
    icon = 'icon'
    medium = 'medium'
    preview = 'preview'


class Error(BaseModel):
    category: str = Field(..., description='The error category')
    context: Optional[Dict[str, List[str]]] = Field(
        None,
        description='Context about the error condition',
        examples=[
            {
                'invalidPropertyName': ['propertyValue'],
                'missingScopes': ['scope1', 'scope2'],
            }
        ],
    )
    correlationId: UUID = Field(
        ...,
        description='A unique identifier for the request. Include this value with any error reports or support tickets',
        examples=['aeb5f871-7f07-4993-9211-075dc63e7cbf'],
    )
    errors: Optional[List[ErrorDetail]] = Field(
        None, description='further information about the error'
    )
    links: Optional[Dict[str, str]] = Field(
        None,
        description='A map of link names to associated URIs containing documentation about the error or recommended remediation steps',
    )
    message: str = Field(
        ...,
        description='A human readable message describing the error along with remediation steps where appropriate',
        examples=['An error occurred'],
    )
    subCategory: Optional[str] = Field(
        None,
        description='A specific category that contains more specific detail about the error',
    )


class FileActionResponse(BaseModel):
    completedAt: datetime = Field(..., description='Time of completion of task.')
    errors: Optional[List[StandardError]] = Field(
        None, description='Descriptive error messages.'
    )
    links: Optional[Dict[str, str]] = Field(
        None, description='Link to check the status of the requested task.'
    )
    numErrors: Optional[int] = Field(
        None, description='Number of errors resulting from the task.'
    )
    requestedAt: Optional[datetime] = Field(
        None, description='Timestamp of when the task was requested.'
    )
    result: Optional[File] = None
    startedAt: datetime = Field(
        ..., description='Timestamp of when the task was started.'
    )
    status: Status = Field(..., description='Current status of the task.')
    taskId: str = Field(..., description='If of the requested task.')


class FolderActionResponse(BaseModel):
    completedAt: datetime = Field(
        ..., description='When the requested changes have been completed.'
    )
    errors: Optional[List[StandardError]] = Field(
        None, description='Detailed errors resulting from the task.'
    )
    links: Optional[Dict[str, str]] = Field(
        None, description='Link to check the status of the task.'
    )
    numErrors: Optional[int] = Field(
        None, description='Number of errors resulting from the requested changes.'
    )
    requestedAt: Optional[datetime] = Field(
        None, description='Timestamp representing when the task was requested.'
    )
    result: Optional[Folder] = None
    startedAt: datetime = Field(
        ..., description='Timestamp representing when the task was started at.'
    )
    status: Status = Field(..., description='Current status of the task.')
    taskId: str = Field(..., description='Id of the task.')


class Paging(BaseModel):
    next: Optional[NextPage] = None
    prev: Optional[PreviousPage] = None


class CollectionResponseFile(BaseModel):
    paging: Optional[Paging] = None
    results: List[File]


class CollectionResponseFolder(BaseModel):
    paging: Optional[Paging] = None
    results: List[Folder]
